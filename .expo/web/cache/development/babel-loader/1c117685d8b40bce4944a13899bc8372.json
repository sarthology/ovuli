{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nexport default function getStateFromPath(path) {\n  var _ref;\n\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (path === '') {\n    return undefined;\n  }\n\n  var initialRoutes = [];\n\n  var configs = (_ref = []).concat.apply(_ref, _toConsumableArray(Object.keys(options).map(function (key) {\n    return createNormalizedConfigs(key, options, [], initialRoutes);\n  })));\n\n  var result;\n  var current;\n  var remaining = path.replace(/[/]+/, '/').replace(/^\\//, '').replace(/\\?.*/, '');\n\n  while (remaining) {\n    var routeNames = void 0;\n    var params = void 0;\n\n    var _loop = function _loop(config) {\n      var match = remaining.match(config.match);\n\n      if (match) {\n        routeNames = _toConsumableArray(config.routeNames);\n        var paramPatterns = config.pattern.split('/').filter(function (p) {\n          return p.startsWith(':');\n        });\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce(function (acc, p, i) {\n            var key = p.replace(/^:/, '');\n            var value = match[i + 1];\n            acc[key] = config.parse && config.parse[key] ? config.parse[key](value) : value;\n            return acc;\n          }, {});\n        }\n\n        remaining = remaining.replace(match[0], '');\n        return \"break\";\n      }\n    };\n\n    for (var _iterator = configs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"]();;) {\n      var _ref2;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref2 = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref2 = _i.value;\n      }\n\n      var config = _ref2;\n\n      var _ret = _loop(config);\n\n      if (_ret === \"break\") break;\n    }\n\n    if (routeNames === undefined) {\n      var segments = remaining.split('/');\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    var state = void 0;\n    var routeName = routeNames.shift();\n    var initialRoute = findInitialRoute(routeName, initialRoutes);\n    state = createNestedState(initialRoute, routeName, routeNames.length === 0, params);\n\n    if (routeNames.length > 0) {\n      var nestedState = state;\n\n      while (routeName = routeNames.shift()) {\n        initialRoute = findInitialRoute(routeName, initialRoutes);\n        nestedState.routes[nestedState.index || 0].state = createNestedState(initialRoute, routeName, routeNames.length === 0, params);\n\n        if (routeNames.length > 0) {\n          nestedState = nestedState.routes[nestedState.index || 0].state;\n        }\n      }\n    }\n\n    if (current) {\n      var _current2;\n\n      while ((_current = current) === null || _current === void 0 ? void 0 : _current.routes[current.index || 0].state) {\n        var _current;\n\n        current = current.routes[current.index || 0].state;\n      }\n\n      current.routes[((_current2 = current) === null || _current2 === void 0 ? void 0 : _current2.index) || 0].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  var query = path.split('?')[1];\n\n  if (query) {\n    var _current4;\n\n    while ((_current3 = current) === null || _current3 === void 0 ? void 0 : _current3.routes[current.index || 0].state) {\n      var _current3;\n\n      current = current.routes[current.index || 0].state;\n    }\n\n    var route = current.routes[((_current4 = current) === null || _current4 === void 0 ? void 0 : _current4.index) || 0];\n\n    var _params = queryString.parse(query);\n\n    var parseFunction = findParseConfigForRoute(route.name, configs);\n\n    if (parseFunction) {\n      Object.keys(_params).forEach(function (name) {\n        if (parseFunction[name] && typeof _params[name] === 'string') {\n          _params[name] = parseFunction[name](_params[name]);\n        }\n      });\n    }\n\n    route.params = _objectSpread({}, route.params, {}, _params);\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(key, routeConfig) {\n  var routeNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var initials = arguments.length > 3 ? arguments[3] : undefined;\n  var configs = [];\n  routeNames.push(key);\n  var value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    if (value !== '') {\n      configs.push(createConfigItem(routeNames, value));\n    }\n  } else if (typeof value === 'object') {\n    if (value.path && value.path !== '') {\n      configs.push(createConfigItem(routeNames, value.path, value.parse));\n    }\n\n    if (value.screens) {\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens)\n        });\n      }\n\n      Object.keys(value.screens).forEach(function (nestedConfig) {\n        var result = createNormalizedConfigs(nestedConfig, value.screens, routeNames, initials);\n        configs.push.apply(configs, _toConsumableArray(result));\n      });\n    }\n  }\n\n  routeNames.pop();\n  return configs;\n}\n\nfunction createConfigItem(routeNames, pattern, parse) {\n  var match = new RegExp('^' + escape(pattern).replace(/:[a-z0-9]+/gi, '([^/]+)') + '/?');\n  return {\n    match: match,\n    pattern: pattern,\n    routeNames: _toConsumableArray(routeNames),\n    parse: parse\n  };\n}\n\nfunction findParseConfigForRoute(routeName, flatConfig) {\n  for (var _iterator2 = flatConfig, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"]();;) {\n    var _ref3;\n\n    if (_isArray2) {\n      if (_i2 >= _iterator2.length) break;\n      _ref3 = _iterator2[_i2++];\n    } else {\n      _i2 = _iterator2.next();\n      if (_i2.done) break;\n      _ref3 = _i2.value;\n    }\n\n    var _config = _ref3;\n\n    if (routeName === _config.routeNames[_config.routeNames.length - 1]) {\n      return _config.parse;\n    }\n  }\n\n  return undefined;\n}\n\nfunction findInitialRoute(routeName, initialRoutes) {\n  for (var _iterator3 = initialRoutes, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"]();;) {\n    var _ref4;\n\n    if (_isArray3) {\n      if (_i3 >= _iterator3.length) break;\n      _ref4 = _iterator3[_i3++];\n    } else {\n      _i3 = _iterator3.next();\n      if (_i3.done) break;\n      _ref4 = _i3.value;\n    }\n\n    var _config2 = _ref4;\n\n    if (_config2.connectedRoutes.includes(routeName)) {\n      return _config2.initialRouteName === routeName ? undefined : _config2.initialRouteName;\n    }\n  }\n\n  return undefined;\n}\n\nfunction createNestedState(initialRoute, routeName, isEmpty, params) {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, _objectSpread({\n          name: routeName\n        }, params && {\n          params: params\n        })]\n      };\n    } else {\n      return {\n        routes: [_objectSpread({\n          name: routeName\n        }, params && {\n          params: params\n        })]\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, {\n          name: routeName,\n          state: {\n            routes: []\n          }\n        }]\n      };\n    } else {\n      return {\n        routes: [{\n          name: routeName,\n          state: {\n            routes: []\n          }\n        }]\n      };\n    }\n  }\n}","map":{"version":3,"sources":["getStateFromPath.tsx"],"names":["options","path","initialRoutes","configs","Object","key","createNormalizedConfigs","remaining","routeNames","params","match","config","paramPatterns","p","value","i","acc","segments","decodeURIComponent","state","routeName","initialRoute","findInitialRoute","createNestedState","nestedState","current","result","query","route","queryString","parseFunction","findParseConfigForRoute","name","initials","routeConfig","createConfigItem","initialRouteName","connectedRoutes","nestedConfig","escape","pattern","parse","index","routes"],"mappings":"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","sourcesContent":["import escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  InitialState,\n} from '@react-navigation/routers';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        parse?: ParseConfig;\n        screens?: Options;\n        initialRouteName?: string;\n      };\n};\n\ntype RouteConfig = {\n  match: RegExp;\n  pattern: string;\n  routeNames: string[];\n  parse: ParseConfig | undefined;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  connectedRoutes: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: Options = {}\n): ResultState | undefined {\n  if (path === '') {\n    return undefined;\n  }\n  let initialRoutes: InitialRouteConfig[] = [];\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[]).concat(\n    ...Object.keys(options).map(key =>\n      createNormalizedConfigs(key, options, [], initialRoutes)\n    )\n  );\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  let remaining = path\n    .replace(/[/]+/, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*/, ''); // Remove query params which we will handle later\n\n  while (remaining) {\n    let routeNames: string[] | undefined;\n    let params: Record<string, any> | undefined;\n\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of configs) {\n      const match = remaining.match(config.match);\n\n      // If our regex matches, we need to extract params from the path\n      if (match) {\n        routeNames = [...config.routeNames];\n\n        const paramPatterns = config.pattern\n          .split('/')\n          .filter(p => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n            const key = p.replace(/^:/, '');\n            const value = match[i + 1]; // The param segments start from index 1 in the regex match result\n\n            acc[key] =\n              config.parse && config.parse[key]\n                ? config.parse[key](value)\n                : value;\n\n            return acc;\n          }, {});\n        }\n\n        // Remove the matched segment from the remaining path\n        remaining = remaining.replace(match[0], '');\n\n        break;\n      }\n    }\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    let state: InitialState;\n    let routeName = routeNames.shift() as string;\n    let initialRoute = findInitialRoute(routeName, initialRoutes);\n\n    state = createNestedState(\n      initialRoute,\n      routeName,\n      routeNames.length === 0,\n      params\n    );\n\n    if (routeNames.length > 0) {\n      let nestedState = state;\n\n      while ((routeName = routeNames.shift() as string)) {\n        initialRoute = findInitialRoute(routeName, initialRoutes);\n        nestedState.routes[nestedState.index || 0].state = createNestedState(\n          initialRoute,\n          routeName,\n          routeNames.length === 0,\n          params\n        );\n        if (routeNames.length > 0) {\n          nestedState = nestedState.routes[nestedState.index || 0]\n            .state as InitialState;\n        }\n      }\n    }\n\n    if (current) {\n      // The state should be nested inside the deepest route we parsed before\n      while (current?.routes[current.index || 0].state) {\n        current = current.routes[current.index || 0].state;\n      }\n\n      (current as PartialState<NavigationState>).routes[\n        current?.index || 0\n      ].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const query = path.split('?')[1];\n\n  if (query) {\n    while (current?.routes[current.index || 0].state) {\n      // The query params apply to the deepest route\n      current = current.routes[current.index || 0].state;\n    }\n\n    const route = (current as PartialState<NavigationState>).routes[\n      current?.index || 0\n    ];\n\n    const params = queryString.parse(query);\n    const parseFunction = findParseConfigForRoute(route.name, configs);\n\n    if (parseFunction) {\n      Object.keys(params).forEach(name => {\n        if (parseFunction[name] && typeof params[name] === 'string') {\n          params[name] = parseFunction[name](params[name] as string);\n        }\n      });\n    }\n\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(\n  key: string,\n  routeConfig: Options,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[]\n): RouteConfig[] {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(key);\n\n  const value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    if (value !== '') {\n      configs.push(createConfigItem(routeNames, value));\n    }\n  } else if (typeof value === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (value.path && value.path !== '') {\n      configs.push(createConfigItem(routeNames, value.path, value.parse));\n    }\n    if (value.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens),\n        });\n      }\n      Object.keys(value.screens).forEach(nestedConfig => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          value.screens as Options,\n          routeNames,\n          initials\n        );\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n}\n\nfunction createConfigItem(\n  routeNames: string[],\n  pattern: string,\n  parse?: ParseConfig\n): RouteConfig {\n  const match = new RegExp(\n    '^' + escape(pattern).replace(/:[a-z0-9]+/gi, '([^/]+)') + '/?'\n  );\n\n  return {\n    match,\n    pattern,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n}\n\nfunction findParseConfigForRoute(\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n}\n\n// tries to find an initial route connected with the one passed\nfunction findInitialRoute(\n  routeName: string,\n  initialRoutes: InitialRouteConfig[]\n): string | undefined {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName\n        ? undefined\n        : config.initialRouteName;\n    }\n  }\n  return undefined;\n}\n\n// returns nested state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nfunction createNestedState(\n  initialRoute: string | undefined,\n  routeName: string,\n  isEmpty: boolean,\n  params?: Record<string, any> | undefined\n): InitialState {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, ...(params && { params }) },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, ...(params && { params }) }],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return { routes: [{ name: routeName as string, state: { routes: [] } }] };\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}